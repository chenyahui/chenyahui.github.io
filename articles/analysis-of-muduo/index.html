<!DOCTYPE html>





<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.7.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.2">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.2">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.2">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.2" color="#222">
  <link rel="alternate" href="/atom.xml" title="沉思录" type="application/atom+xml">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css?v=7.4.2">


<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.4.2',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":"default"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":false,"async":false,"transition":{"post_block":null,"post_header":null,"post_body":null,"coll_header":null,"sidebar":null}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="muduo是陈硕大神个人开发的C++的TCP网络编程库。muduo基于Reactor模式实现。Reactor模式也是目前大多数Linux端高性能网络编程框架和网络应用所选择的主要架构，例如内存数据库Redis和Java的Netty库等。 陈硕的《Linux多线程服务器端编程》一书对muduo整个架构进行了非常详尽的介绍和分析，可以说是学习muduo源码和设计理念最好的资料了。这本书也非常推荐大家购">
<meta name="keywords" content="TCP,源码,Reactor">
<meta property="og:type" content="article">
<meta property="og:title" content="muduo源码剖析">
<meta property="og:url" content="http://www.cyhone.com/articles/analysis-of-muduo/index.html">
<meta property="og:site_name" content="沉思录">
<meta property="og:description" content="muduo是陈硕大神个人开发的C++的TCP网络编程库。muduo基于Reactor模式实现。Reactor模式也是目前大多数Linux端高性能网络编程框架和网络应用所选择的主要架构，例如内存数据库Redis和Java的Netty库等。 陈硕的《Linux多线程服务器端编程》一书对muduo整个架构进行了非常详尽的介绍和分析，可以说是学习muduo源码和设计理念最好的资料了。这本书也非常推荐大家购">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://www.cyhone.com/img/reactor/single_thread_reactor.png">
<meta property="og:image" content="http://www.cyhone.com/img/reactor/main_sub_reactor.jpg">
<meta property="og:updated_time" content="2019-11-03T09:22:16.602Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="muduo源码剖析">
<meta name="twitter:description" content="muduo是陈硕大神个人开发的C++的TCP网络编程库。muduo基于Reactor模式实现。Reactor模式也是目前大多数Linux端高性能网络编程框架和网络应用所选择的主要架构，例如内存数据库Redis和Java的Netty库等。 陈硕的《Linux多线程服务器端编程》一书对muduo整个架构进行了非常详尽的介绍和分析，可以说是学习muduo源码和设计理念最好的资料了。这本书也非常推荐大家购">
<meta name="twitter:image" content="http://www.cyhone.com/img/reactor/single_thread_reactor.png">
  <link rel="canonical" href="http://www.cyhone.com/articles/analysis-of-muduo/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>muduo源码剖析</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ec99ce8d168c9260e5d744401582acc9";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <div class="container">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">沉思录</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">一些思考和总结</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类<span class="badge">8</span></a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档<span class="badge">20</span></a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签<span class="badge">21</span></a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/chenyahui" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
      <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block post">
    <link itemprop="mainEntityOfPage" href="http://www.cyhone.com/articles/analysis-of-muduo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cyhone">
      <meta itemprop="description" content="每有会意，便欣然忘食">
      <meta itemprop="image" content="/img/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沉思录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">muduo源码剖析

          
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2018-06-12 23:51:37" itemprop="dateCreated datePublished" datetime="2018-06-12T23:51:37+08:00">2018-06-12</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-03 17:22:16" itemprop="dateModified" datetime="2019-11-03T17:22:16+08:00">2019-11-03</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/网络编程/" itemprop="url" rel="index"><span itemprop="name">网络编程</span></a></span>

                
                
              
            </span>
          

          
            <span id="/articles/analysis-of-muduo/" class="post-meta-item leancloud_visitors" data-flag-title="muduo源码剖析" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
        
      
      <span class="post-meta-item-text">评论：</span>
    
    <a title="valine" href="/articles/analysis-of-muduo/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/articles/analysis-of-muduo/" itemprop="commentCount"></span></a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><a href="https://github.com/chenshuo/muduo" target="_blank" rel="noopener">muduo</a>是<a href="http://chenshuo.com" target="_blank" rel="noopener">陈硕</a>大神个人开发的C++的TCP网络编程库。muduo基于Reactor模式实现。Reactor模式也是目前大多数Linux端高性能网络编程框架和网络应用所选择的主要架构，例如内存数据库Redis和Java的Netty库等。</p>
<p>陈硕的《Linux多线程服务器端编程》一书对muduo整个架构进行了非常详尽的介绍和分析，可以说是学习muduo源码和设计理念最好的资料了。这本书也非常推荐大家购买阅读，感觉是后台开发的必读书目了。</p>
<p>而本文则主要是从源码角度辅助理解整个muduo的实现，同时也姑且算是对muduo的一个小小的补充。</p>
<p>同时本人也提供了一个<a href="https://github.com/chenyahui/AnnotatedCode/tree/master/muduo" target="_blank" rel="noopener">muduo注释版</a>，以辅助大家参考学习。<br><a id="more"></a></p>
<h1 id="muduo的架构和概念"><a href="#muduo的架构和概念" class="headerlink" title="muduo的架构和概念"></a>muduo的架构和概念</h1><p>muduo中类的职责和概念划分的非常清晰，在《Linux多线程服务器端编程》一书的6.3.1章节有详细的介绍。实际上目前很多网络库的接口设计也都受到了muduo的影响，例如360的evpp等。</p>
<p>而muduo的整体风格受到netty的影响，整个架构依照Reactor模式，基本与如下图所示相符：</p>
<p><img src="/img/reactor/single_thread_reactor.png" alt="单线程Reactor模式"></p>
<p>所谓Reactor模式，是有一个循环的过程，监听对应事件是否触发，触发时调用对应的callback进行处理。</p>
<p>这里的事件在muduo中包括Socket可读写事件、定时器事件。在其他网络库中如libevent也包括了signal、用户自定义事件等。</p>
<p>负责事件循环的部分在muduo命名为<code>EventLoop</code>，其他库如netty、libevent也都有对应的组件。 </p>
<p>负责监听事件是否触发的部分，在muduo中叫做<code>Poller</code>。muduo提供了epoll和poll两种来实现，默认是epoll实现。<br>通过环境变量<code>MUDUO_USE_POLL</code>来决定是否使用poll:<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Poller* Poller::newDefaultPoller(EventLoop* loop)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 通过此环境变量来决定使用poll还是epoll</span></span><br><span class="line">  <span class="keyword">if</span> (::getenv(<span class="string">"MUDUO_USE_POLL"</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PollPoller(loop);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EPollPoller(loop);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此外，图中的acceptor负责accept新连接，并将新连接分发到subReactor。这个组件在muduo中也叫做<code>Acceptor</code>。<br>关于图中的其他部分，会在<a href="#muduo的线程模型">muduo的线程模型</a>一节有详细介绍。</p>
<h1 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h1><p>本文首先从最简单的echo server入手，来介绍muduo的基本使用，同时也方便后面概念的理解。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(<span class="keyword">const</span> muduo::net::TcpConnectionPtr&amp; conn,</span></span></span><br><span class="line"><span class="function"><span class="params">                           muduo::net::Buffer* buf,</span></span></span><br><span class="line"><span class="function"><span class="params">                           muduo::Timestamp time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  conn-&gt;send(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    muduo::net::EventLoop loop;</span><br><span class="line">    muduo::net::<span class="function">InetAddress <span class="title">listenAddr</span><span class="params">(<span class="number">2007</span>)</span></span>;</span><br><span class="line">    <span class="function">TcpServer <span class="title">server</span><span class="params">(&amp;loop, listenAddr)</span></span>;</span><br><span class="line">    server.setMessageCallback(onMessage);</span><br><span class="line">    server.start();</span><br><span class="line">    loop.loop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>echo-server的代码量非常简洁。一个典型的muduo的TcpServer工作流程如下：</p>
<ol>
<li>建立一个事件循环器EventLoop</li>
<li>建立对应的业务服务器TcpServer</li>
<li>设置TcpServer的Callback</li>
<li>启动server</li>
<li>开启事件循环</li>
</ol>
<p>陈硕认为，TCP网络编程的本质是处理三个半事件，即：</p>
<ol>
<li>连接的建立</li>
<li>连接的断开：包括主动断开和被动断开</li>
<li>消息到达，文件描述符可读。</li>
<li>消息发送完毕。这个算半个事件。</li>
</ol>
<p>我们接下来分析下muduo是怎么处理和实现这三个半事件的</p>
<h1 id="连接的建立"><a href="#连接的建立" class="headerlink" title="连接的建立"></a>连接的建立</h1><p>在我们单纯使用linux的API，编写一个简单的Tcp服务器时，建立一个新的连接通常需要四步：</p>
<blockquote>
<p>步骤1. socket() // 调用socket函数建立监听socket<br>步骤2. bind()   // 绑定地址和端口<br>步骤3. listen() // 开始监听端口<br>步骤4. accept() // 返回新建立连接的fd</p>
</blockquote>
<p>我们接下来分析下，这四个步骤在muduo中都是何时进行的：</p>
<p>首先在TcpServer对象构建时，TcpServer的属性acceptor同时也被建立。<br>在Acceptor的构造函数中分别调用了socket函数和bind函数完成了<strong>步骤1</strong>和<strong>步骤2</strong>。<br>即，当<code>TcpServer server(&amp;loop, listenAddr);</code>执行结束时，监听socket已经建立好，并已绑定到对应地址和端口了。</p>
<p>而当执行<code>server.start()</code>时，主要做了两个工作：</p>
<ol>
<li>在监听socket上启动listen函数，也就是<strong>步骤3</strong>；</li>
<li>将监听socket的可读事件注册到EventLoop中。</li>
</ol>
<p>此时，程序已完成对地址的监听，但还不够，因为此时程序的主角<code>EventLoop</code>尚未启动。<br>当调用<code>loop.loop()</code>时，程序开始监听该socket的可读事件。</p>
<p>当新连接请求建立时，可读事件触发，此时该事件对应的callback在EventLoop::loop()中被调用。<br>该事件的callback实际上就是Acceptor::handleRead()方法。</p>
<p>在Acceptor::handleRead()方法中，做了三件事：</p>
<ol>
<li>调用了accept函数，完成了<strong>步骤4</strong>，实现了连接的建立。得到一个已连接socket的fd</li>
<li>创建TcpConnection对象</li>
<li>将已连接socket的可读事件注册到EventLoop中。</li>
</ol>
<p>这里还有一个需要注意的点，创建的TcpConnnection对象是个shared_ptr，该对象会被保存在TcpServer的connections中。这样才能保证引用计数大于0，对象不被释放。</p>
<p>至此，一个新的连接已完全建立好，其可读事件也已注册到EventLoop中了。</p>
<h1 id="消息的读取"><a href="#消息的读取" class="headerlink" title="消息的读取"></a>消息的读取</h1><p>上节讲到，在新连接建立的时候，会将新连接的socket的可读事件注册到EventLoop中。<br>假如客户端发送消息，导致已连接socket的可读事件触发，该事件对应的callback同样也会在EventLoop::loop()中被调用。</p>
<p>该事件的callback实际上就是TcpConnection::handleRead方法。<br>在TcpConnection::handleRead方法中，主要做了两件事：</p>
<ol>
<li>从socket中读取数据，并将其放入inputbuffer中</li>
<li>调用messageCallback，执行业务逻辑。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> n = inputBuffer_.readFd(channel_-&gt;fd(), &amp;savedErrno);</span><br><span class="line"><span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    messageCallback_(shared_from_this(), &amp;inputBuffer_, receiveTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>messageCallback是在建立新连接时，将<code>TcpServer::messageCallback</code>方法bind到了<code>TcpConnection::messageCallback</code>的方法。</p>
<p>TcpServer::messageCallback就是业务逻辑的主要实现函数。通常情况下，我们可以在里面实现消息的编解码、消息的分发等工作，这里就不再深入探讨了。</p>
<p>在我们上面给出的示例代码中，echo-server的messageCallback非常简单，就是直接将得到的数据，重新send回去。在实际的业务处理中，一般都会调用TcpConnection::send()方法，给客户端回复消息。</p>
<p>这里需要注意的是，在messageCallback中，用户会有可能会把任务抛给自定义的Worker线程池处理。<br>但是这个在Worker线程池中任务，切忌直接对Buffer的操作。因为Buffer并不是线程安全的。</p>
<p>我们需要记住一个准则:</p>
<blockquote>
<p>所有对IO和buffer的读写，都应该在IO线程中完成。</p>
</blockquote>
<p>一般情况下，先在交给Worker线程池之前，应该现在IO线程中把Buffer进行切分解包等动作。将解包后的消息交由线程池处理，避免多个线程操作同一个资源。</p>
<h1 id="消息的发送"><a href="#消息的发送" class="headerlink" title="消息的发送"></a>消息的发送</h1><p>用户通过调用TcpConnection::send()向客户端回复消息。由于muduo中使用了OutputBuffer，因此消息的发送过程比较复杂。</p>
<p>首先需要注意的是线程安全问题, 对于消息的读写必须都在EventLoop的同一个线程(通常称为IO线程)中进行：<br>因此，TcpConnection::send保证了线程安全性，它是这么做的：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> TcpConnection::send(<span class="keyword">const</span> StringPiece&amp; message)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (state_ == kConnected)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (loop_-&gt;isInLoopThread())</span><br><span class="line">    &#123;</span><br><span class="line">      sendInLoop(message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      loop_-&gt;runInLoop(</span><br><span class="line">          boost::bind(&amp;TcpConnection::sendInLoop,</span><br><span class="line">                      <span class="keyword">this</span>,     <span class="comment">// FIXME</span></span><br><span class="line">                      message.as_string()));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>检测send的时候，是否在当前IO线程，如果是的话，直接进行写相关操作<code>sendInLoop</code>。<br>如果不在一个线程的话，需要将该任务抛给IO线程执行<code>runInloop</code>, 以保证write动作是在IO线程中执行的。我们后面会讲解<code>runInloop</code>的具体实现。</p>
<p>在sendInloop中，做了下面几件事：</p>
<ol>
<li>假如OutputBuffer为空，则直接向socket写数据</li>
<li>如果向socket写数据没有写完，则统计剩余的字节个数，并进行下一步。没有写完可能是因为此时socket的TCP缓冲区已满了。</li>
<li>如果此时OutputBuffer中的旧数据的个数和未写完字节个数之和大于highWaterMark，则将highWaterMarkCallback放入待执行队列中</li>
<li><strong>将对应socket的可写事件注册到EventLoop中</strong></li>
</ol>
<p>注意，直到发送的时候，才把socket的可写事件注册到了EventLoop中。之前只注册了可读事件。</p>
<p>连接socket的可写事件对应的callback是TcpConnection::handleWrite()<br>当某个socket的可写事件触发时，TcpConnection::handleWrite会做两个工作：</p>
<ol>
<li>尽可能将数据从OutputBuffer中向socket中write数据</li>
<li>如果OutputBuffer没有剩余的，则<strong>将该socket的可写事件移除</strong>，并调用writeCompleteCallback</li>
</ol>
<h2 id="为什么要移除可写事件"><a href="#为什么要移除可写事件" class="headerlink" title="为什么要移除可写事件"></a>为什么要移除可写事件</h2><p>因为当OutputBuffer中没数据时，我们不需要向socket中写入数据。但是此时socket一直是处于可写状态的， 这将会导致TcpConnection::handleWrite()一直被触发。然而这个触发毫无意义，因为并没有什么可以写的。</p>
<p>所以muduo的处理方式是，当OutputBuffer还有数据时，socket可写事件是注册状态。当OutputBuffer为空时，则将socket的可写事件移除。</p>
<p>此外，highWaterMarkCallback和writeCompleteCallback一般配合使用，起到限流的作用。在《linux多线程服务器端编程》一书的8.9.3一节中有详细讲解。这里就不再赘述了</p>
<h1 id="连接的断开"><a href="#连接的断开" class="headerlink" title="连接的断开"></a>连接的断开</h1><p>我们看下muduo对于连接的断开是怎么处理的。<br>连接的断开分为被动断开和主动断开。主动断开和被动断开的处理方式基本一致，因此本文只讲下被动断开的部分。</p>
<p>被动断开即远程端断开了连接，server端需要感知到这个断开的过程，然后进行的相关的处理。</p>
<p>其中感知远程断开这一步是在Tcp连接的可读事件处理函数<code>handleRead</code>中进行的：当对socket进行read操作时，返回值为0，则说明此时连接已断开。</p>
<p>接下来会做四件事情：</p>
<ol>
<li>将该TCP连接对应的事件从EventLoop移除</li>
<li>调用用户的ConnectionCallback</li>
<li>将对应的TcpConnection对象从Server移除。</li>
<li>close对应的fd。此步骤是在析构函数中被动触发的，当TcpConnection对象被移除后，引用计数为0，对象析构时会调用close。</li>
</ol>
<h1 id="runInLoop的实现"><a href="#runInLoop的实现" class="headerlink" title="runInLoop的实现"></a>runInLoop的实现</h1><p>在讲解消息的发送过程时候，我们讲到为了保证对buffer和socket的写动作是在io线程中进行，使用了一个<code>runInLoop</code>函数，将该写任务抛给了io线程处理。</p>
<p>我们接下来看下<code>runInLoop</code>的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> EventLoop::runInLoop(<span class="keyword">const</span> Functor&amp; cb)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (isInLoopThread())</span><br><span class="line">  &#123;</span><br><span class="line">    cb();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    queueInLoop(cb);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里可以看到，做了一层判断。如果调用时是此EventLoop的运行线程，则直接执行此函数。<br>否则调用<code>queueInLoop</code>函数。我们看下<code>queueInLoop</code>的实现。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> EventLoop::queueInLoop(<span class="keyword">const</span> Functor&amp; cb)</span><br><span class="line">&#123;</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">  pendingFunctors_.push_back(cb);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!isInLoopThread() || callingPendingFunctors_)</span><br><span class="line">  &#123;</span><br><span class="line">    wakeup();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有两个动作：</p>
<ol>
<li>加锁，然后将该函数放到该EventLoop的pendingFunctors_队列中。</li>
<li>判断是否要唤醒EventLoop，如果是则调用wakeup()唤醒该EventLoop。</li>
</ol>
<p>这里有几个问题：</p>
<ul>
<li>为什么要唤醒EventLoop？</li>
<li>wakeup是怎么实现的?</li>
<li>pendingFunctors_是如何被消费的?</li>
</ul>
<h2 id="为什么要唤醒EventLoop"><a href="#为什么要唤醒EventLoop" class="headerlink" title="为什么要唤醒EventLoop"></a>为什么要唤醒EventLoop</h2><p>我们首先调用了<code>pendingFunctors_.push_back(cb);</code>, 将该函数放在pendingFunctors_中。EventLoop的每一轮循环最后会调用doPendingFunctors依次执行这些函数。</p>
<p>而EventLoop的唤醒是通过epoll_wait实现的，如果此时该EventLoop中迟迟没有事件触发，那么epoll_wait一直就会阻塞。<br>这样会导致，pendingFunctors_迟迟不能被执行了。</p>
<p>所以对EventLoop的唤醒是必要的。</p>
<h2 id="wakeup是怎么实现的"><a href="#wakeup是怎么实现的" class="headerlink" title="wakeup是怎么实现的"></a>wakeup是怎么实现的</h2><p>muduo这里采用了对eventfd的读写来实现对EventLoop的唤醒。</p>
<p>在EventLoop建立之后，就创建一个eventfd，并将其可读事件注册到EventLoop中。</p>
<p><code>wakeup()</code>的过程本质上是对这个eventfd进行写操作，以触发该eventfd的可读事件。这样就起到了唤醒EventLoop的作用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> EventLoop::wakeup()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">uint64_t</span> one = <span class="number">1</span>;</span><br><span class="line">  sockets::write(wakeupFd_, &amp;one, <span class="keyword">sizeof</span> one);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很多库为了兼容macos，往往使用pipe来实现这个功能。muduo采用了eventfd，性能更好些，但代价是不能支持macos了。不过muduo似乎从一开始的定位就不打算支持？</p>
<h2 id="doPendingFunctors的实现"><a href="#doPendingFunctors的实现" class="headerlink" title="doPendingFunctors的实现"></a>doPendingFunctors的实现</h2><p>本部分讲下<code>doPendingFunctors</code>的实现，muduo是如何处理这些待处理的函数的，以及中间用了哪些优化操作。<br>代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> EventLoop::doPendingFunctors()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Functor&gt; functors;</span><br><span class="line"> </span><br><span class="line">  callingPendingFunctors_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">  <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">  functors.swap(pendingFunctors_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; functors.size(); ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    functors[i]();</span><br><span class="line">  &#125;</span><br><span class="line">  callingPendingFunctors_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从代码可以看到，函数非常简单。大概只有十行代码，但是这十行却有两个非常巧妙的措施。</p>
<p><strong>callingPendingFunctors_的作用</strong></p>
<p>从代码可以看出，如果callingPendingFunctors_为false，则说明此时尚未开始执行doPendingFunctors函数。<br>这个有什么作用呢，我们需要结合下queueInLoop中，对是否执行wakeup()的判断</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (!isInLoopThread() || callingPendingFunctors_)</span><br><span class="line">&#123;</span><br><span class="line">  wakeup();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里还需要结合下EventLoop循环的实现，其中<code>doPendingFunctors()</code>是<strong>每轮循环的最后一步处理</strong>。<br>如果调用queueInLoop和EventLoop在同一个线程，且callingPendingFunctors_为false时，则说明：<strong>此时尚未执行到doPendingFunctors()。</strong><br>那么此时即使不用wakeup，也可以在之后照旧执行doPendingFunctors()了。</p>
<p>这么做的好处非常明显，可以减少对eventfd的io读写。</p>
<p><strong>锁范围的减少</strong><br>在此函数中，有一段特别的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Functor&gt; functors;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">  functors.swap(pendingFunctors_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个作用是pendingFunctors_和functors的内容进行交换，实际上就是此时functors持有了pendingFunctors_的内容，而pendingFunctors_被清空了。</p>
<p>这个好处是什么呢？<br>如果不这么做，直接遍历pendingFunctors_,然后处理对应的函数。这样的话，锁会一直等到所有函数处理完才会被释放。在此期间，queueInLoop将不可用。</p>
<p>而以上的写法，可以极大减小锁范围，整个锁的持有时间就是swap那一下的时间。待处理函数执行的时候，其他线程还是可以继续调用queueInLoop。</p>
<h1 id="muduo的线程模型"><a href="#muduo的线程模型" class="headerlink" title="muduo的线程模型"></a>muduo的线程模型</h1><p>muduo默认是单线程模型的，即只有一个线程，里面对应一个EventLoop。这样整体对于线程安全的考虑可能就比较简单了，<br>但是muduo也可以支持以下几种线程模型：</p>
<h2 id="主从reactor模式"><a href="#主从reactor模式" class="headerlink" title="主从reactor模式"></a>主从reactor模式</h2><p>主从reactor是netty的默认模型，一个reactor对应一个EventLoop。主Reactor只有一个，只负责监听新的连接，accept后将这个连接分配到子Reactor上。子Reactor可以有多个。这样可以分摊一个Eventloop的压力，性能方面可能会更好。如下图所示：</p>
<p><img src="/img/reactor/main_sub_reactor.jpg" alt="主从Reactor模式"></p>
<p>在muduo中也可以支持主从Reactor，其中主Reactor的EventLoop就是TcpServer的构造函数中的<code>EventLoop*</code>参数。Acceptor会在此EventLoop中运行。</p>
<p>而子Reactor可以通过<code>TcpServer::setThreadNum(int)</code>来设置其个数。因为一个Eventloop只能在一个线程中运行，所以线程的个数就是子Reactor的个数。</p>
<p>如果设置了子Reactor，新的连接会通过Round Robin的方式分配给其中一个EventLoop来管理。如果没有设置子Reactor，则是默认的单线程模型，新的连接会再由主Reactor进行管理。</p>
<p>但其实这里似乎有些不合适的地方：多个TcpServer之间可以共享同一个主EventLoop，但是子Eventloop线程池却不能共享，这个是每个TcpServer独有的。<br>这里不太清楚是muduo的设计问题，还是作者有意为之。不过netty的主EventLoop和子Eventloop池都是可以共享的。</p>
<h2 id="业务线程池"><a href="#业务线程池" class="headerlink" title="业务线程池"></a>业务线程池</h2><p>对于一些阻塞型或者耗时型的任务，例如MySQL操作等。这些显然是不能放在IO线程（即EventLoop所在的线程）中运行的，因为会严重影响EventLoop的正常运行。具体原理可以查看<a href="http://www.cyhone.com/articles/reunderstanding-of-non-blocking-io/">另外一篇博客</a>。</p>
<p>对于这类耗时型的任务，一般做法是可以放在另外单独线程池中运行，这样就不会阻塞IO线程的运行了。我们一般把这种处理耗时任务的线程叫做Worker线程。</p>
<p>muduo本身没有提供一套直接使用Worker线程池的方式，但是muduo本身提供了线程池的相关类<code>ThreadPool</code>。muduo官方的推荐做法是，在OnMessage中，自行进行包的切分，然后将数据和对应的处理函数打包成Task的方式提交给线程池。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>个人认为，muduo源码对于学习网络编程和项目设计非常有帮助, 里面几乎包含了大部分网络编程和框架设计的最佳实践，配合《Linux多线程服务器端编程》一书，可以学到很多东西。<br>基于这几个方面来说，muduo绝对是一个值得一探究竟的优质源码。<br>此外，不但是网络编程方面，如何将复杂的底层细节封装好，暴露出友好的通用业务层接口，如何设计类的职责，对象的生命周期管理等方面，muduo都给了我们一个很好的示范。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>《Linux多线程服务器端编程》</li>
<li><a href="http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf" target="_blank" rel="noopener">Scalable IO in Java</a></li>
</ul>

    </div>

    
    
    
        <div id="wechat_subscriber" style="display: block; padding: 10px 0; margin: 20px auto; width: 100%; text-align: center;">
  <img id="wechat_subscriber_qcode" src="/img/wechat_subscriber.jpg" alt="cyhone wechat" style="width: 200px; max-width: 100%;">
  <div>欢迎关注公众号【编程沉思录】</div>
</div>

      
        
      
        <div id="reward-container">
  <div></div>
  <button id="reward-button" disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
        
      
      <div style="display: inline-block">
        <img src="/img/pay/wx-pay.png" alt="cyhone 微信支付">
        <p>微信支付</p>
      </div>
        
      
      <div style="display: inline-block">
        <img src="/img/pay/ali-pay.png" alt="cyhone 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

      
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>cyhone</li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://www.cyhone.com/articles/analysis-of-muduo/" title="muduo源码剖析">http://www.cyhone.com/articles/analysis-of-muduo/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li>
</ul>
</div>

      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/tags/TCP/" rel="tag"><i class="fa fa-tag"></i> TCP</a>
            
              <a href="/tags/源码/" rel="tag"><i class="fa fa-tag"></i> 源码</a>
            
              <a href="/tags/Reactor/" rel="tag"><i class="fa fa-tag"></i> Reactor</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/articles/db-doc-generator/" rel="next" title="自动生成数据库文档小工具的诞生">
                  <i class="fa fa-chevron-left"></i> 自动生成数据库文档小工具的诞生
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/articles/client-time-calibration/" rel="prev" title="客户端秒级时间同步方案">
                  客户端秒级时间同步方案 <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          
    
    <div class="comments" id="comments"></div>
  

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-fixed">
      <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#muduo的架构和概念"><span class="nav-text">muduo的架构和概念</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#一个简单的例子"><span class="nav-text">一个简单的例子</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#连接的建立"><span class="nav-text">连接的建立</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#消息的读取"><span class="nav-text">消息的读取</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#消息的发送"><span class="nav-text">消息的发送</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么要移除可写事件"><span class="nav-text">为什么要移除可写事件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#连接的断开"><span class="nav-text">连接的断开</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#runInLoop的实现"><span class="nav-text">runInLoop的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么要唤醒EventLoop"><span class="nav-text">为什么要唤醒EventLoop</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#wakeup是怎么实现的"><span class="nav-text">wakeup是怎么实现的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#doPendingFunctors的实现"><span class="nav-text">doPendingFunctors的实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#muduo的线程模型"><span class="nav-text">muduo的线程模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#主从reactor模式"><span class="nav-text">主从reactor模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#业务线程池"><span class="nav-text">业务线程池</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-text">总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考"><span class="nav-text">参考</span></a></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/img/avatar.jpg"
      alt="cyhone">
  <p class="site-author-name" itemprop="name">cyhone</p>
  <div class="site-description" itemprop="description">每有会意，便欣然忘食</div>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
      
        
      
        <a href="https://github.com/chenyahui" title="GitHub &rarr; https://github.com/chenyahui" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i></a>
      </span>
    
      <span class="links-of-author-item">
      
      
      
        
      
        <a href="mailto:cyhone@qq.com" title="E-Mail &rarr; mailto:cyhone@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i></a>
      </span>
    
      <span class="links-of-author-item">
      
      
      
        
      
        <a href="https://www.zhihu.com/people/cyhone" title="Zhihu &rarr; https://www.zhihu.com/people/cyhone" rel="noopener" target="_blank"><i class="fa fa-fw fa-custom zhihu"></i></a>
      </span>
    
  </div>



      </div>
      </div>
      <div class="sidebar-inner" style="margin-top:12px;padding:1px;">
          <div id="wechat_subscriber" style="display: block; padding: 10px 0; margin: 20px auto; width: 100%; text-align: center;">
              <img id="wechat_subscriber_qcode" src="/img/wechat_subscriber.jpg" alt="cyhone wechat" style="width: 200px; max-width: 100%;">
              <div style="color: #999;font-size: 14px;">
              欢迎关注公众号【编程沉思录】
              </div>
          </div>
      </div>
    </div>
    </div>

  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright"><a href="http://www.beian.miit.gov.cn" rel="noopener" target="_blank">豫ICP备18011028号 </a>
  <a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=" rel="noopener" target="_blank"> </a>&copy; 2015 – <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cyhone</span>
</div>

        












        
      </div>
    </footer>
  </div>

  


  <script src="//cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js"></script>
<script src="/js/utils.js?v=7.4.2"></script>
<script src="/js/schemes/pisces.js?v=7.4.2"></script>

<script src="/js/next-boot.js?v=7.4.2"></script>



  





















  

  
    
      
<script type="text/x-mathjax-config">

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    
  

  

  


<script>
NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail';
  guest = guest.split(',').filter(item => {
    return GUEST.includes(item);
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'sb9fJUcsRooG9QU63KflHMhU-gzGzoHsz',
    appKey: 'DVy4Enbaa5UpxREeLinbWIcG',
    placeholder: '请在上方填写您的邮箱，邮件不会被公开',
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: true,
    lang: 'zh-cn' || 'zh-cn',
    path: location.pathname
  });
}, window.Valine);
</script>

</body>
</html>
