<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#464159">
<meta name="generator" content="Hexo 3.7.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.6.1">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.6.1">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.6.1">
  <link rel="mask-icon" href="/images/logo.svg?v=7.6.1" color="#464159">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta name="google-site-verification" content="gcDrMPbZlMtAIc7xAPBwFUjnApzpvfqSbVIKT3R8fbA">
  <meta name="baidu-site-verification" content="F7xr7OXgnX">

<link rel="stylesheet" href="/css/main.css?v=7.6.1">


<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://www.cyhone.com').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.6.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":"default"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":false,"async":false,"transition":{"post_block":null,"post_header":null,"post_body":null,"coll_header":null,"sidebar":null}}
  };
</script>

  <meta name="description" content="随着 Golang 的兴起，协程尤其是有栈协程 (stackful coroutine) 越来越受到程序员的关注。协程几乎成了程序员的一套必备技能。 云风实现了一套 C 语言的协程库，整体背景可以参考其 博客。 这个协程库非常轻量级，一共也才 200 多行代码，使用上更贴近于 lua 的写法（众所周知，云风是知名的 lua 粉)。整体基于 ucontext 和共享栈模型实现了有栈协程，代码质量毋庸">
<meta name="keywords" content="源码,协程">
<meta property="og:type" content="article">
<meta property="og:title" content="云风 coroutine 协程库源码分析">
<meta property="og:url" content="http://www.cyhone.com/articles/analysis-of-cloudwu-coroutine/index.html">
<meta property="og:site_name" content="编程沉思录">
<meta property="og:description" content="随着 Golang 的兴起，协程尤其是有栈协程 (stackful coroutine) 越来越受到程序员的关注。协程几乎成了程序员的一套必备技能。 云风实现了一套 C 语言的协程库，整体背景可以参考其 博客。 这个协程库非常轻量级，一共也才 200 多行代码，使用上更贴近于 lua 的写法（众所周知，云风是知名的 lua 粉)。整体基于 ucontext 和共享栈模型实现了有栈协程，代码质量毋庸">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://www.cyhone.com/img/coroutine/coroutine_dummy.png">
<meta property="og:image" content="http://www.cyhone.com/img/coroutine/coroutine-state-machine.png">
<meta property="og:updated_time" content="2019-12-10T05:07:50.063Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="云风 coroutine 协程库源码分析">
<meta name="twitter:description" content="随着 Golang 的兴起，协程尤其是有栈协程 (stackful coroutine) 越来越受到程序员的关注。协程几乎成了程序员的一套必备技能。 云风实现了一套 C 语言的协程库，整体背景可以参考其 博客。 这个协程库非常轻量级，一共也才 200 多行代码，使用上更贴近于 lua 的写法（众所周知，云风是知名的 lua 粉)。整体基于 ucontext 和共享栈模型实现了有栈协程，代码质量毋庸">
<meta name="twitter:image" content="http://www.cyhone.com/img/coroutine/coroutine_dummy.png">

<link rel="canonical" href="http://www.cyhone.com/articles/analysis-of-cloudwu-coroutine/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>云风 coroutine 协程库源码分析 | 编程沉思录</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ec99ce8d168c9260e5d744401582acc9";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">编程沉思录</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">一些思考和总结</h1>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">10</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">24</span></a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">26</span></a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/chenyahui" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.cyhone.com/articles/analysis-of-cloudwu-coroutine/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/img/avatar.jpg">
      <meta itemprop="name" content="cyhone">
      <meta itemprop="description" content="每有会意，便欣然忘食">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="编程沉思录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          云风 coroutine 协程库源码分析
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-19 14:26:19" itemprop="dateCreated datePublished" datetime="2019-09-19T14:26:19+08:00">2019-09-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-10 13:07:50" itemprop="dateModified" datetime="2019-12-10T13:07:50+08:00">2019-12-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/协程/" itemprop="url" rel="index">
                    <span itemprop="name">协程</span>
                  </a>
                </span>
            </span>

          
            <span id="/articles/analysis-of-cloudwu-coroutine/" class="post-meta-item leancloud_visitors" data-flag-title="云风 coroutine 协程库源码分析" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/articles/analysis-of-cloudwu-coroutine/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/articles/analysis-of-cloudwu-coroutine/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>随着 Golang 的兴起，协程尤其是有栈协程 (stackful coroutine) 越来越受到程序员的关注。协程几乎成了程序员的一套必备技能。</p>
<p>云风实现了一套 <a href="https://github.com/cloudwu/coroutine/" target="_blank" rel="noopener">C 语言的协程库</a>，整体背景可以参考其 <a href="https://blog.codingnow.com/2012/07/c_coroutine.html" target="_blank" rel="noopener">博客</a>。</p>
<p>这个协程库非常轻量级，一共也才 200 多行代码，使用上更贴近于 lua 的写法（众所周知，云风是知名的 lua 粉)。整体基于 ucontext 和共享栈模型实现了有栈协程，代码质量毋庸置疑，本文将详细剖析该协程库的实现原理。</p>
<p>同时，我也提供了 <a href="https://github.com/chenyahui/AnnotatedCode/tree/master/coroutine" target="_blank" rel="noopener">coroutine 注释版</a>，辅助大家理解 coroutine 的代码。</p>
<a id="more"></a>
<h1 id="协程的背景"><a class="markdownIt-Anchor" href="#协程的背景"></a> 协程的背景</h1>
<p>协程主要有两大优点：</p>
<ol>
<li>相比线程更加轻量级
<ul>
<li>线程的创建和调度都是在内核态，而协程是在用户态完成的</li>
<li>线程的个数往往受限于 CPU 核数，线程过多，会造成大量的核间切换。而协程无需考虑这些</li>
</ul>
</li>
<li>将异步流程同步化处理：此问题在知乎上有非常多的 <a href="https://www.zhihu.com/question/32218874/answer/216801915" target="_blank" rel="noopener">经典回答</a>。尤其在 RPC 中进行多服务并发协作的时候，相比于回调式的做法，协程的好处更加明显。这个对于后端程序员的意义更大，非常解放生产力。这里就不再赘述了。</li>
</ol>
<p>微信基于 c++ 实现的协程库 <a href="https://github.com/Tencent/libco/" target="_blank" rel="noopener">libco</a>，hook 了网络 IO 所需要大部分的系统函数，实现了当 IO 阻塞时协程的自动切换。<br>
而 Golang 做的则更加极致，直接将协程和自动切换的概念集成进了语言。这里不细讲 libco 和 GoRoutine 的实现了，有机会会对这些做更详细的剖析。</p>
<p>协程再细分可以分为有栈协程和无栈协程：我们今天讲的云风的 coroutine，包括微信的 libco、GoRoutine，都是属于有栈协程。无栈协程包括 ES6 中的 await/async、Python 中的协程等。两种协程实现原理有很大的不同，本文主要基于 coroutine 对有栈协程的原理进行详细的分析。</p>
<h1 id="有栈协程的原理"><a class="markdownIt-Anchor" href="#有栈协程的原理"></a> 有栈协程的原理</h1>
<p>一个程序要真正运行起来，需要两个因素：可执行代码段、数据。体现在 CPU 中，主要包含以下几个方面：</p>
<ol>
<li>EIP 寄存器，用来存储 CPU 要读取指令的地址</li>
<li>ESP 寄存器：指向当前线程栈的栈顶位置</li>
<li>其他通用寄存器的内容：包括代表函数参数的 rdi、rsi 等等。</li>
<li>线程栈中的内存内容。</li>
</ol>
<p>这些数据内容，我们一般将其称为 “上下文” 或者 “现场”。</p>
<p>有栈协程的原理，就是从线程的上下文下手，如果把线程的上下文完全改变。即：改变 EIP 寄存的内容，指向其他指令地址；改变线程栈的内存内容等等。<br>
这样的话，当前线程运行的程序也就完全改变了，是一个全新的程序。</p>
<p>Linux 下提供了一套函数，叫做 ucontext 簇函数，可以用来获取和设置当前线程的上下文内容。这也是 coroutine 的核心方法。</p>
<h1 id="coroutine-的使用"><a class="markdownIt-Anchor" href="#coroutine-的使用"></a> coroutine 的使用</h1>
<p>我们首先基于 coroutine 的例子来讲下 coroutine 的基本使用，以方便后面原理的讲解</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">args</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(struct schedule * S, <span class="keyword">void</span> *ud)</span> </span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">args</span> * <span class="title">arg</span> = <span class="title">ud</span>;</span></span><br><span class="line">	<span class="keyword">int</span> start = arg-&gt;n;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"coroutine %d : %d\n"</span>,coroutine_running(S) , start + i);</span><br><span class="line">		<span class="comment">// 切出当前协程</span></span><br><span class="line">		coroutine_yield(S);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(struct schedule *S)</span> </span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">args</span> <span class="title">arg1</span> = &#123;</span><span class="number">0</span>&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">args</span> <span class="title">arg2</span> = &#123;</span><span class="number">100</span>&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建两个协程</span></span><br><span class="line">	<span class="keyword">int</span> co1 = coroutine_new(S, foo, &amp;arg1);</span><br><span class="line">	<span class="keyword">int</span> co2 = coroutine_new(S, foo, &amp;arg2);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"main start\n"</span>);</span><br><span class="line">	<span class="keyword">while</span> (coroutine_status(S,co1) &amp;&amp; coroutine_status(S,co2)) &#123;</span><br><span class="line">		<span class="comment">// 使用协程 co1</span></span><br><span class="line">		coroutine_resume(S,co1);</span><br><span class="line">		<span class="comment">// 使用协程 co2</span></span><br><span class="line">		coroutine_resume(S,co2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"main end\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 创建一个协程调度器</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">schedule</span> * <span class="title">S</span> = <span class="title">coroutine_open</span>();</span></span><br><span class="line"></span><br><span class="line">	test(S);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 关闭协程调度器</span></span><br><span class="line">	coroutine_close(S);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码看来，首先利用 <code>coroutine_open</code> 创建了协程调度器 S，用来统一管理全部的协程。<br>
同时在 test 函数中，创建了两个协程 co1 和 co2，不断的反复 yield 和 resume 协程，直至两个协程执行完毕。</p>
<p>可以看出，最核心的几个对象和函数是:</p>
<ol>
<li><code>struct schedule* S</code> 协程调度器</li>
<li><code>coroutine_resume(S,co1);</code> 切入该协程</li>
<li><code>coroutine_yield(S);</code> 切出该协程</li>
</ol>
<p>接下来，会从这几点出发，分析 coroutine 的原理。建议大家在阅读下文时，同时对照我做的 <a href="https://github.com/chenyahui/AnnotatedCode/tree/master/coroutine" target="_blank" rel="noopener">coroutine 注释版</a>。</p>
<h1 id="struct-schedule-协程调度器"><a class="markdownIt-Anchor" href="#struct-schedule-协程调度器"></a> struct schedule 协程调度器</h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">schedule</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span> <span class="built_in">stack</span>[STACK_SIZE];	<span class="comment">// 运行时栈，此栈即是共享栈</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">ucontext_t</span> main; <span class="comment">// 主协程的上下文</span></span><br><span class="line">	<span class="keyword">int</span> nco;        <span class="comment">// 当前存活的协程个数</span></span><br><span class="line">	<span class="keyword">int</span> cap;        <span class="comment">// 协程管理器的当前最大容量，即可以同时支持多少个协程。如果不够了，则进行 2 倍扩容</span></span><br><span class="line">	<span class="keyword">int</span> running;    <span class="comment">// 正在运行的协程 ID</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">coroutine</span> **<span class="title">co</span>;</span> <span class="comment">// 一个一维数组，用于存放所有协程。其长度等于 cap</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>协程调度器 schedule 负责管理所有协程，有几个属性非常重要：</p>
<ol>
<li><code>struct coroutine **co;</code> 是一个一维数组，存放了目前所有的协程。</li>
<li><code>ucontext_t main;</code> 主协程的上下文，方便后面协程执行完后切回到主协程。</li>
<li><code>char stack[STACK_SIZE];</code> 这个非常重要，是所有协程的运行时栈。具体共享栈的原理会在下文讲到。</li>
</ol>
<p>此外，<code>coroutine_open</code> 负责创建并初始化一个协程调度器，<code>coroutine_close</code> 负责销毁协程调度器以及清理其管理的所有协程。</p>
<h1 id="协程的创建-coroutine_new"><a class="markdownIt-Anchor" href="#协程的创建-coroutine_new"></a> 协程的创建: coroutine_new</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">struct coroutine &#123;</span><br><span class="line">	coroutine_func func; <span class="comment">// 协程所用的函数</span></span><br><span class="line">	<span class="keyword">void</span> *ud;  <span class="comment">// 协程参数</span></span><br><span class="line">	ucontext_t ctx; <span class="comment">// 协程上下文</span></span><br><span class="line">	struct schedule * sch; <span class="comment">// 该协程所属的调度器</span></span><br><span class="line">	ptrdiff_t cap; 	 <span class="comment">// 已经分配的内存大小</span></span><br><span class="line">	ptrdiff_t size; <span class="comment">// 当前协程运行时栈，保存起来后的大小</span></span><br><span class="line">	<span class="keyword">int</span> status;	<span class="comment">// 协程当前的状态</span></span><br><span class="line">	<span class="keyword">char</span> *stack; <span class="comment">// 当前协程的保存起来的运行时栈</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>coroutine_new</code> 负责创建并初始化一个新协程对象，同时将该协程对象放到协程调度器里面。</p>
<p>这里的实现有两个非常有意思的点：</p>
<ol>
<li>** 扩容 **：当目前尚存活的线程个数 <code>nco</code> 已经等于协程调度器的容量 <code>cap</code> 了，这个时候需要对协程调度器进行扩容，这里直接就是非常经典简单的 2 倍扩容。</li>
<li>** 如果无需扩容，则需要找到一个空的位置，放置初始化好的协程 **。这里一般直接从数组第一位开始找，直到找到空的位置即可。但是云风把这里处理成从第 <code>nco</code> 位开始寻找（<code>nco</code> 代表当前存活的个数。因为一般来说，前面几位最开始都是存活的，从第 <code>nco</code> 位开始找，效率会更高。</li>
</ol>
<p>这样，一个协程对象就被创建好，此时该协程的状态是 <code>READY</code>，但尚未正式执行。</p>
<p><code>coroutine_resume</code> 函数会切入到指定协程中执行。当前正在执行的协程的上下文会被保存起来，同时上下文替换成新的协程，该协程的状态将被置为 <code>RUNNING</code>。</p>
<p>进入 <code>coroutine_resume</code> 函数的前置状态有两个 <code>READY</code> 和 <code>SUSPEND</code>，这两个状态下 <code>coroutine_resume</code> 的处理方法也是有很大不同。我们先看下协程在 READY 状态下进行 <code>coroutine_resume</code> 的流程。</p>
<h1 id="coroutine_resumeready-running"><a class="markdownIt-Anchor" href="#coroutine_resumeready-running"></a> coroutine_resume(READY -&gt; RUNNING）</h1>
<p>这块代码比较短，但是非常重要，所以我就直接贴代码了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化 ucontext_t 结构体，将当前的上下文放到 C-&gt;ctx 里面</span></span><br><span class="line">getcontext(&amp;C-&gt;ctx);</span><br><span class="line"><span class="comment">// 将当前协程的运行时栈的栈顶设置为 S-&gt;stack，每个协程都这么设置，这就是所谓的共享栈。（注意，这里是栈顶）</span></span><br><span class="line">C-&gt;ctx.uc_stack.ss_sp = S-&gt;stack;</span><br><span class="line">C-&gt;ctx.uc_stack.ss_size = STACK_SIZE;</span><br><span class="line">C-&gt;ctx.uc_link = &amp;S-&gt;main;</span><br><span class="line">S-&gt;running = id;</span><br><span class="line">C-&gt;status = COROUTINE_RUNNING;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置执行 C-&gt;ctx 函数, 并将 S 作为参数传进去</span></span><br><span class="line">uintptr_t ptr = (uintptr_t)S;</span><br><span class="line">makecontext(&amp;C-&gt;ctx, (<span class="keyword">void</span> (*)(<span class="keyword">void</span>)) mainfunc, <span class="number">2</span>, (uint32_t)ptr, (uint32_t)(ptr&gt;&gt;<span class="number">32</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将当前的上下文放入 S-&gt;main 中，并将 C-&gt;ctx 的上下文替换到当前上下文</span></span><br><span class="line">swapcontext(&amp;S-&gt;main, &amp;C-&gt;ctx);</span><br></pre></td></tr></table></figure>
<p>这段函数非常的重要，有几个不可忽视的点：</p>
<ol>
<li><code>getcontext(&amp;C-&gt;ctx);</code> 初始化 ucontext_t 结构体，将当前的上下文放到 C-&gt;ctx 里面</li>
<li><code>C-&gt;ctx.uc_stack.ss_sp = S-&gt;stack;</code> 设置当前协程的运行时栈，也是共享栈。</li>
<li><code>C-&gt;ctx.uc_link = &amp;S-&gt;main;</code> 如果协程执行完，则切换到 <code>S-&gt;main</code> 主协程中进行执行。如果不设置, 则默认为 NULL，那么协程执行完，整个程序就结束了。</li>
</ol>
<p>接下来是 makecontext，这个函数用来设置对应 ucontext 的执行函数。如上，将 <code>C-&gt;ctx</code> 的执行函数体设置为了 mainfunc。</p>
<p>makecontext 后面的两个参数也非常有意思，这个可以看出来是把一个指针掰成了两个 int 作为参数传给 mainfunc 了。而在 mainfunc 的实现可以看出来，又会把这两个 int 拼成了一个 <code>struct schedule*</code>。</p>
<p>那么，为什么不直接传 <code>struct schedule*</code> 呢，而要这么做，通过先拆两半，再在函数中拼起来？</p>
<p>这是因为 makecontext 的函数指针的参数是 <code>uint32_t</code> 类型，在 64 位系统下，一个 <code>uint32_t</code> 没法承载一个指针, 所以基于兼容性的考虑，才采用了这种做法。</p>
<p>接下来调用了 <code>swapcontext</code> 函数，这个函数比较简单，但也非常核心。作用是将当前的上下文内容放入 <code>S-&gt;main</code> 中，并将 <code>C-&gt;ctx</code> 的上下文替换到当前上下文。这样的话，将会执行新的上下文对应的程序了。在 coroutine 中, 也就是开始执行 <code>mainfunc</code> 这个函数。(<code>mainfunc</code> 是对用户提供的协程函数的封装)。</p>
<h1 id="协程的切出coroutine_yield"><a class="markdownIt-Anchor" href="#协程的切出coroutine_yield"></a> 协程的切出：coroutine_yield</h1>
<p>调用 <code>coroutine_yield</code> 可以使当前正在运行的协程切换到主协程中运行。此时，该协程会进入 <code>SUSPEND</code> 状态</p>
<p><code>coroutine_yield</code> 的具体实现依赖于两个行为：</p>
<ol>
<li>调用 <code>_save_stack</code> 将当前协程的栈保存起来。因为 coroutine 是基于共享栈的，所以协程的栈内容需要单独保存起来。</li>
<li><code>swapcontext</code> 将当前上下文保存到当前协程的 ucontext 里面，同时替换当前上下文为主协程的上下文。 这样的话，当前协程会被挂起，主协程会被继续执行。</li>
</ol>
<p>这里也有个点极其关键, 就是如何保存当前协程的运行时栈, 也就是如何获取整个栈的内存空间。</p>
<p>这里我们需要了解下栈内存空间的布局，即栈的生长方向是从高地址往低地址。我们只要找到栈的栈顶和栈底的地址，就可以找到整个栈内存空间了。</p>
<p>在 coroutine 中，因为协程的运行时栈的内存空间是自己分配的。在 coroutine_resume 阶段设置了 <code>C-&gt;ctx.uc_stack.ss_sp = S.S-&gt;stack</code>。根据以上理论，栈的生长方向是高地址到低地址，因此栈底的就是内存地址最大的位置，即 <code>S-&gt;stack + STACK_SIZE</code> 就是栈底位置。</p>
<p>那么，如何找到栈顶的位置呢？coroutine 是基于以下方法做的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> _save_stack(C,S-&gt;<span class="built_in">stack</span> + STACK_SIZE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _save_stack(struct coroutine *C, <span class="keyword">char</span> *top) &#123;</span><br><span class="line">	<span class="keyword">char</span> dummy = <span class="number">0</span>;</span><br><span class="line">	assert(top - &amp;dummy &lt;= STACK_SIZE);</span><br><span class="line">    <span class="comment">// 如果已分配内存小于当前栈的大小，则释放内存重新分配</span></span><br><span class="line">	<span class="keyword">if</span> (C-&gt;cap &lt; top - &amp;dummy) &#123;</span><br><span class="line">		<span class="built_in">free</span>(C-&gt;<span class="built_in">stack</span>);</span><br><span class="line">		C-&gt;cap = top-&amp;dummy;</span><br><span class="line">		C-&gt;<span class="built_in">stack</span> = <span class="built_in">malloc</span>(C-&gt;cap);</span><br><span class="line">	&#125;</span><br><span class="line">	C-&gt;size = top - &amp;dummy;</span><br><span class="line">    <span class="comment">// 从 dummy 拷贝 size 内存到 C-&gt;stack</span></span><br><span class="line">	<span class="built_in">memcpy</span>(C-&gt;<span class="built_in">stack</span>, &amp;dummy, C-&gt;size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里特意用到了一个 dummy 变量，这个 dummy 的作用非常关键也非常巧妙，大家可以细细体会下。因为 dummy 变量是刚刚分配到栈上的，此时就位于 ** 栈的最顶部位置 **。整个内存布局如下图所示：<br>
<img src="/img/coroutine/coroutine_dummy.png" alt=""></p>
<p>因此整个栈的大小就是从栈底到栈顶，<code>S-&gt;stack + STACK_SIZE - &amp;dummy</code>。</p>
<p>最后又调用了 memcpy 将当前运行时栈的内容，拷贝到了 <code>C-&gt;stack</code> 中保存了起来。</p>
<h1 id="coroutine_resumesuspend-running"><a class="markdownIt-Anchor" href="#coroutine_resumesuspend-running"></a> coroutine_resume(SUSPEND -&gt; RUNNING）</h1>
<p>当协程被 yield 之后会进入 <code>SUSPEND</code> 阶段，对该协程调用 <code>coroutine_resume</code> 会再次切入该协程。</p>
<p>这里的实现有两个重要的点：</p>
<ol>
<li>
<p><code>memcpy(S-&gt;stack + STACK_SIZE - C-&gt;size, C-&gt;stack, C-&gt;size);</code><br>
我们知道，在 yield 的时候，协程的栈内容保存到了 C-&gt;stack 数组中。<br>
这个时候，就是用 memcpy 把协程的之前保存的栈内容，重新拷贝到运行时栈里面。这里有个点，拷贝的开始位置，需要简单计算下<br>
<code>S-&gt;stack + STACK_SIZE - C-&gt;size</code> 这个位置就是之前协程的栈顶位置。</p>
</li>
<li>
<p><code>swapcontext(&amp;S-&gt;main, &amp;C-&gt;ctx);</code> 交换上下文。这点在上文有具体描述。</p>
</li>
</ol>
<h1 id="状态机转换"><a class="markdownIt-Anchor" href="#状态机转换"></a> 状态机转换</h1>
<p>在 coroutine 中协程定义了四种状态，整个运行期间，也是根据这四种状态进行轮转。</p>
<p><img src="/img/coroutine/coroutine-state-machine.png" alt=""></p>
<h1 id="共享栈"><a class="markdownIt-Anchor" href="#共享栈"></a> 共享栈</h1>
<p>共享栈这个词在 libco 中提到的多，其实 coroutine 也是用的共享栈模型。<br>
共享栈这个东西说起来很玄乎，实际原理不复杂，本质就是所有的协程在运行的时候都使用同一个栈空间。</p>
<p>共享栈对标的是非共享栈，也就是每个协程的栈空间都是独立的，固定大小。好处是协程切换的时候，内存不用拷贝来拷贝去。坏处则是 ** 内存空间浪费 **.</p>
<p>因为栈空间在运行时不能随时扩容，为了防止栈内存不够，所以要预先每个协程都要预先开一个足够的栈空间使用。当然很多协程用不了这么大的空间，就必然造成内存的浪费。</p>
<p>共享栈则是提前开了一个足够大的栈空间 (coroutine 默认是 1M)。所有的栈运行的时候，都使用这个栈空间。<br>
conroutine 是这么设置每个协程的运行时栈：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">C-&gt;ctx.uc_stack.ss_sp = S-&gt;<span class="built_in">stack</span>;</span><br><span class="line">C-&gt;ctx.uc_stack.ss_size = STACK_SIZE;</span><br></pre></td></tr></table></figure>
<p>对协程调用 yield 的时候，该协程栈内容暂时保存起来，保存的时候需要用到多少内存就开多少，这样就减少了内存的浪费。(即_save_stack 函数的内容)。<br>
当 resume 该协程的时候，协程之前保存的栈内容，会被重新拷贝到运行时栈中。</p>
<p>这就是所谓的共享栈的原理。</p>
<h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1>
<p>云风的协程库代码非常简约，可以帮助我们更好的理解协程实现的基本原理。后面有机会也会细讲下微信 libco 的实现原理，这个更贴近于工业级的使用，用法也非常强大。</p>
<h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1>
<ul>
<li><a href="https://github.com/zfengzhen/Blog/blob/master/article/ucontext%E7%B0%87%E5%87%BD%E6%95%B0%E5%AD%A6%E4%B9%A0.md" target="_blank" rel="noopener">ucontext 簇函数学习</a></li>
<li><a href="https://www.zhihu.com/question/32218874" target="_blank" rel="noopener">为什么觉得协程是趋势?</a></li>
<li><a href="https://gameinstitute.qq.com/community/detail/107515" target="_blank" rel="noopener">天涯明月刀 - 无栈协程的应用</a></li>
<li><a href="https://zhengyinyong.com/ucontext-usage-and-coroutine.html" target="_blank" rel="noopener">ucontext 函数族的使用及协程库的实现</a></li>
<li><a href="https://langzi989.github.io/tags/ucontext-t/" target="_blank" rel="noopener">C++ 协程实现及原理</a></li>
<li><a href="https://www.zhihu.com/question/52193579/answer/129597362" target="_blank" rel="noopener">腾讯开源的 libco 号称千万级协程支持，那个共享栈模式原理是什么?</a></li>
<li><a href="https://blog.csdn.net/u011228889/article/details/79759834" target="_blank" rel="noopener">基于云风协程库的协程原理解读</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/27339191" target="_blank" rel="noopener">x86-64 下函数调用及栈帧原理</a></li>
</ul>

    </div>

    
    
    
    <div id="wechat_subscriber" style="display: block; padding: 10px 0; margin: 20px auto; width: 100%; text-align: center;">
        <img id="wechat_subscriber_qcode" src="/img/wechat_subscriber_search.png" alt="cyhone wechat" style="width: 750px;max-width:100%;">
    <!--div>欢迎关注公众号【编程沉思录】</div-->
    </div>
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>cyhone
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://www.cyhone.com/articles/analysis-of-cloudwu-coroutine/" title="云风 coroutine 协程库源码分析">http://www.cyhone.com/articles/analysis-of-cloudwu-coroutine/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/源码/" rel="tag"><i class="fa fa-tag"></i> 源码</a>
              <a href="/tags/协程/" rel="tag"><i class="fa fa-tag"></i> 协程</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/articles/optimization-of-websocket-push-system/" rel="prev" title="WebSocket 订单推送稳定性优化方案">
      <i class="fa fa-chevron-left"></i> WebSocket 订单推送稳定性优化方案
    </a></div>
      <div class="post-nav-item">
    <a href="/articles/why-move-no-work-in-lambda/" rel="next" title="c++ lambda 内 std::move 失效问题的思考">
      c++ lambda 内 std::move 失效问题的思考 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#协程的背景"><span class="nav-text"> 协程的背景</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#有栈协程的原理"><span class="nav-text"> 有栈协程的原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#coroutine-的使用"><span class="nav-text"> coroutine 的使用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#struct-schedule-协程调度器"><span class="nav-text"> struct schedule 协程调度器</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#协程的创建-coroutine_new"><span class="nav-text"> 协程的创建: coroutine_new</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#coroutine_resumeready-running"><span class="nav-text"> coroutine_resume(READY -&gt; RUNNING）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#协程的切出coroutine_yield"><span class="nav-text"> 协程的切出：coroutine_yield</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#coroutine_resumesuspend-running"><span class="nav-text"> coroutine_resume(SUSPEND -&gt; RUNNING）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#状态机转换"><span class="nav-text"> 状态机转换</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#共享栈"><span class="nav-text"> 共享栈</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-text"> 总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考"><span class="nav-text"> 参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="cyhone"
      src="/img/avatar.jpg">
  <p class="site-author-name" itemprop="name">cyhone</p>
  <div class="site-description" itemprop="description">每有会意，便欣然忘食</div>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/chenyahui" title="GitHub → https://github.com/chenyahui" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:cyhone@qq.com" title="E-Mail → mailto:cyhone@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://zhuanlan.zhihu.com/ruminations-on-code" title="Zhihu → https://zhuanlan.zhihu.com/ruminations-on-code" rel="noopener" target="_blank"><i class="fa fa-fw fa-custom zhihu"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="rss → /atom.xml"><i class="fa fa-fw fa-rss"></i></a>
      </span>
  </div>


<div id="wechat_subscriber" style="display: block; padding: 10px 0; margin: 20px auto; width: 100%; text-align: center;">
    <img id="wechat_subscriber_qcode" src="/img/wechat_subscriber.jpg" alt="cyhone wechat" style="width: 200px; max-width: 100%;">
    <div style="color: #999;font-size: 14px;">
      欢迎关注公众号【编程沉思录】
    </div>
</div>
      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        
  <div class="beian"><a href="http://www.beian.miit.gov.cn" rel="noopener" target="_blank">豫ICP备18011028号 </a>
  </div>

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cyhone</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js"></script>
<script src="/js/utils.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el: '#valine-comments',
      verify: false,
      notify: false,
      appId: 'sb9fJUcsRooG9QU63KflHMhU-gzGzoHsz',
      appKey: 'DVy4Enbaa5UpxREeLinbWIcG',
      placeholder: "请在上方填写您的邮箱，邮件不会被公开",
      avatar: 'mm',
      meta: guest,
      pageSize: '10' || 10,
      visitor: true,
      lang: 'zh-cn' || 'zh-cn',
      path: location.pathname,
      recordIP: false,
      serverURLs: ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
